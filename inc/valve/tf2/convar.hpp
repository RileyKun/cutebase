//
// Created by Riley on 4/28/2024.
//

#pragma once

#include "memory.hpp"

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class i_con_var;
class c_command;

//-----------------------------------------------------------------------------
// ConVar flags
//-----------------------------------------------------------------------------
// The default, no flags at all
#define FCVAR_NONE         0

// Command to ConVars and ConCommands
// ConVar Systems
#define FCVAR_UNREGISTERED (1 << 0) // If this is set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY \
  (1 << 1) // Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is
           // defined.
#define FCVAR_GAMEDLL   (1 << 2) // defined by the game DLL
#define FCVAR_CLIENTDLL (1 << 3) // defined by the client DLL
#define FCVAR_HIDDEN \
  (1 << 4) // Hidden. Doesn't appear in find or auto complete. Like DEVELOPMENTONLY, but can't be compiled
           // out.

// ConVar only
#define FCVAR_PROTECTED \
  (1 << 5) // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not
           // bland/zero, 0 otherwise as value
#define FCVAR_SPONLY   (1 << 6) // This cvar cannot be changed by clients connected to a multiplayer server.
#define FCVAR_ARCHIVE  (1 << 7) // set to cause it to be saved to vars.rc
#define FCVAR_NOTIFY   (1 << 8) // notifies players when changed
#define FCVAR_USERINFO (1 << 9) // changes the client's info string

#define FCVAR_PRINTABLEONLY \
  (1 << 10) // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
#define FCVAR_UNLOGGED \
  (1 << 11) // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
#define FCVAR_NEVER_AS_STRING (1 << 12) // never try to print that cvar

// It's a ConVar that's shared between the client and the server.
// At signon, the values of all such ConVars are sent from the server to the client (skipped for local
//  client, of course )
// If a change is requested it must come from the console (i.e., no remote client changes)
// If a value is changed while a server is active, it's replicated to all connected clients
#define FCVAR_REPLICATED \
  (1 << 13)                   // server setting enforced on clients, TODO rename to FCAR_SERVER at some time
#define FCVAR_CHEAT (1 << 14) // Only useable in singleplayer / debug / multiplayer & sv_cheats
#define FCVAR_SS \
  (1 << 15) // causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated
#define FCVAR_DEMO                   (1 << 16) // record this cvar when starting a demo file
#define FCVAR_DONTRECORD             (1 << 17) // don't record these command in demofiles
#define FCVAR_SS_ADDED               (1 << 18) // This is one of the "added" FCVAR_SS variables for the splitscreen players
#define FCVAR_RELEASE                (1 << 19) // Cvars tagged with this are the only cvars avaliable to customers
#define FCVAR_RELOAD_MATERIALS       (1 << 20) // If this cvar changes, it forces a material reload
#define FCVAR_RELOAD_TEXTURES        (1 << 21) // If this cvar changes, if forces a texture reload

#define FCVAR_NOT_CONNECTED          (1 << 22) // cvar cannot be changed by a client that is connected to a server
#define FCVAR_MATERIAL_SYSTEM_THREAD (1 << 23) // Indicates this cvar is read from the material system thread
#define FCVAR_ARCHIVE_GAMECONSOLE    (1 << 24) // cvar written to config.cfg on the Xbox

#define FCVAR_SERVER_CAN_EXECUTE \
  (1 << 28) // the server is allowed to execute this command on clients via
            // ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
#define FCVAR_SERVER_CANNOT_QUERY \
  (1 << 29) // If this is set, then the server is not allowed to query this cvar's value (via
            // IServerPluginHelpers::StartQueryCvarValue).
#define FCVAR_CLIENTCMD_CAN_EXECUTE \
  (1 << 30) // IVEngineClient::ClientCmd is allowed to execute this command.
            // Note: IVEngineClient::ClientCmd_Unrestricted can run any client command.

#define FCVAR_ACCESSIBLE_FROM_THREADS \
  (1 << 25) // used as a debugging tool necessary to check material system thread convars
// #define FCVAR_AVAILABLE			(1<<26)
// #define FCVAR_AVAILABLE			(1<<27)
// #define FCVAR_AVAILABLE			(1<<31)

#define FCVAR_MATERIAL_THREAD_MASK \
  (FCVAR_RELOAD_MATERIALS | FCVAR_RELOAD_TEXTURES | FCVAR_MATERIAL_SYSTEM_THREAD)

//-----------------------------------------------------------------------------
// Called when a ConVar changes value
// NOTE: For FCVAR_NEVER_AS_STRING ConVars, pOldValue == NULL
//-----------------------------------------------------------------------------
typedef void (*fn_change_callback)(i_con_var* var, const char* old_value, float float_old_value);

//-----------------------------------------------------------------------------
// Abstract interface for ConVars
//-----------------------------------------------------------------------------
class _color; // we have our own colors separate to what the engine has
class i_con_var {
public:
  virtual void set_value( const char* value ) = 0;
  virtual void set_value( float value ) = 0;
  virtual void set_value( int value ) = 0;
  virtual const char* get_name( void ) const = 0;
  virtual bool is_flag_set( int flag ) const = 0;
};

//-----------------------------------------------------------------------------
// Uncomment me to test for threading issues for material system convars
// NOTE: You want to disable all threading when you do this
// +host_thread_mode 0 +r_threaded_particles 0 +sv_parallel_packentities 0 +sv_disable_querycache 0
//-----------------------------------------------------------------------------
// #define CONVAR_TEST_MATERIAL_THREAD_CONVARS 1

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class convar;
class c_command;
class con_command;
class con_command_base;
struct characterset_t;

//-----------------------------------------------------------------------------
// Any executable that wants to use ConVars need to implement one of
// these to hook up access to console variables.
//-----------------------------------------------------------------------------
class con_command_base_accessor {
public:
  virtual bool register_con_command_base(con_command_base* var) = 0;
};

//-----------------------------------------------------------------------------
// Called when a ConCommand needs to execute
//-----------------------------------------------------------------------------
typedef void (*fn_command_callback_v1)(void);
typedef void (*fn_command_callback)(const c_command& command);

#define COMMAND_COMPLETION_MAXITEMS    64
#define COMMAND_COMPLETION_ITEM_LENGTH 64

//-----------------------------------------------------------------------------
// Returns 0 to COMMAND_COMPLETION_MAXITEMS worth of completion strings
//-----------------------------------------------------------------------------
typedef int (*fn_command_completion_callback)(
    const char* partial, char commands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH]);

//-----------------------------------------------------------------------------
// Interface version
//-----------------------------------------------------------------------------
class i_command_callback {
public:
  virtual void command_callback(const c_command& command) = 0;
};

class i_command_completion_callback {
public:
  virtual int command_completion_comeback(const char* partial, void* commands) = 0;
};

struct cvar_dll_identifier;

//-----------------------------------------------------------------------------
// Purpose: The base console invoked command/cvar interface
//-----------------------------------------------------------------------------
class con_command_base {
public:
  virtual ~con_command_base(void);
  virtual bool is_command(void) const;
  virtual bool is_flag_set(int flag) const;
  virtual void add_flags(int flags);
  virtual const char* get_name(void) const;
  virtual const char* get_help_text(void) const;
  virtual bool is_registered(void) const;
  virtual cvar_dll_identifier get_dll_identifier() const;
  virtual void create_base(const char* name, const char* help_string = 0, int flags = 0);

  con_command_base* next;
  bool _is_registered;
  const char* name;
  const char* help_string;
  int flags;

protected:
  static con_command_base* con_command_bases;
  static con_command_base_accessor* accessor;
};

//-----------------------------------------------------------------------------
// Command tokenizer
//-----------------------------------------------------------------------------
class c_command {
public:
  enum {
    COMMAND_MAX_ARGC = 64,
    COMMAND_MAX_LENGTH = 512,
  };

  int         argc;
  int         argv0size;
  char        argsbuffer[COMMAND_MAX_LENGTH];
  char        argvbuffer[COMMAND_MAX_LENGTH];
  const char* argv[COMMAND_MAX_ARGC];
};

//-----------------------------------------------------------------------------
// Purpose: The console invoked command
//-----------------------------------------------------------------------------
class con_command : public con_command_base {
public:
  typedef con_command_base base_class;

  virtual ~con_command(void);

  virtual bool is_command(void) const;

  virtual int  auto_complete_suggest(const char* partial, void*& commands);

  virtual bool can_auto_complete(void);

  // Invoke the function
  virtual void dispatch(const c_command& command);

private:
  // NOTE: To maintain backward compat, we have to be very careful:
  // All public virtual methods must appear in the same order always
  // since engine code will be calling into this code, which *does not match*
  // in the mod code; it's using slightly different, but compatible versions
  // of this class. Also: Be very careful about adding new fields to this class.
  // Those fields will not exist in the version of this class that is instanced
  // in mod code.

  // Call this function when executing the command
  union {
    fn_command_callback_v1 fn_command_callback_v1;
    fn_command_callback   fn_command_callback;
    i_command_callback*     command_callback;
  };

  union {
    fn_command_completion_callback fn_completion_callback;
    i_command_completion_callback* command_completion_callback;
  };

  bool has_completion_callback : 1;
  bool using_new_command_completion_callback : 1;
  bool using_command_callback_interface : 1;
};

//-----------------------------------------------------------------------------
// Purpose: A console variable
//-----------------------------------------------------------------------------
class convar : public con_command_base, public i_con_var {
public:
  virtual ~convar( void );
  virtual bool is_flag_set( int flag ) const;
  virtual const char* get_help_text( void ) const;
  virtual bool is_registered( void ) const;
  virtual const char* get_name( void ) const;
  virtual void add_flags( int flags );
  virtual	bool is_command( void ) const;
  virtual void set_value( const char* value );
  virtual void set_value( float value );
  virtual void set_value( int value );
  virtual void internal_set_value( const char* value );
  virtual void internal_set_float_value( float new_value, bool force = false );
  virtual void internal_set_int_value( int value );
  virtual bool clamp_value( float& value );
  virtual void change_string_value( const char* temp_val, float old_value );
  virtual void init( );

  inline float get_float( void ) const;
  inline int get_int( void ) const;
  inline bool	get_bool( ) const { return !!get_int( ); }
  inline char const* get_string( void ) const;

private:
  convar* parent;
  const char* default_value;
  char* string;
  int string_length;
  float float_value;
  int int_value;
  bool has_min;
  float min_value;
  bool has_max;
  float max_value;
  bool has_comp_min;
  float comp_min_value;
  bool has_comp_max;
  float comp_max_value;
  bool competitive_restrictions;
  fn_change_callback m_fn_change_callback;
};

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as a float
// Output : float
//-----------------------------------------------------------------------------
inline float convar::get_float(void) const {
  return parent->float_value;
}

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as an int
// Output : int
//-----------------------------------------------------------------------------
inline int convar::get_int(void) const {
  return parent->int_value;
}

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as a string, return "" for bogus string pointer, etc.
// Output : const char *
//-----------------------------------------------------------------------------
inline const char* convar::get_string(void) const {
  if (flags & FCVAR_NEVER_AS_STRING)
    return "FCVAR_NEVER_AS_STRING";

  char const* str = parent->string;
  return str ? str : "";
}

//-----------------------------------------------------------------------------
// Client systems are singleton objects in the client codebase responsible for
// various tasks
// The order in which the client systems appear in this list are the
// order in which they are initialized and updated. They are shut down in
// reverse order from which they are initialized.
//-----------------------------------------------------------------------------
enum init_return_val {
  INIT_FAILED = 0,
  INIT_OK,

  INIT_LAST_VAL,
};

typedef void* (*create_interface_fn)(const char* name, int* return_code);
class i_app_system {
public:
  // Here's where the app systems get to learn about each other
  virtual bool            connect(create_interface_fn factory) = 0;
  virtual void            disconnect() = 0;

  // Here's where systems can access other interfaces implemented by this object
  // Returns NULL if it doesn't implement the requested interface
  virtual void*           query_interface(const char* interface_name) = 0;

  // Init, shutdown
  virtual init_return_val init() = 0;
  virtual void            shutdown() = 0;
};

//-----------------------------------------------------------------------------
// Used to display console messages
//-----------------------------------------------------------------------------
class i_console_display_func {
public:
  virtual void color_print(const _color& clr, const char* message) = 0;
  virtual void print(const char* message) = 0;
  virtual void dprint(const char* message) = 0;
};

class i_cvar_query : public i_app_system {
public:
  virtual bool are_convars_linked(const convar* child, const convar* parent) = 0;
};

//-----------------------------------------------------------------------------
// Purpose: DLL interface to ConVars/ConCommands
//-----------------------------------------------------------------------------
class i_cvar : public i_app_system {
public:
  virtual cvar_dll_identifier allocate_dll_identifier( ) = 0;
  virtual void register_con_command( con_command_base* command_base ) = 0;
  virtual void unregister_con_command( con_command_base* command_base ) = 0;
  virtual void unregister_con_commands( cvar_dll_identifier id ) = 0;
  virtual const char* get_command_line_value( const char* variable_name ) = 0;
  virtual con_command_base* find_command_base( const char* name ) = 0;
  virtual const con_command_base* find_command_base( const char* name ) const = 0;
  virtual convar* find_var( const char* var_name ) = 0;
  virtual const convar* find_var( const char* var_name ) const = 0;
  virtual con_command* find_command( const char* name ) = 0;
  virtual const con_command* find_command( const char* name ) const = 0;
  virtual con_command_base* get_commands( void ) = 0;
  virtual const con_command_base* get_commands( void ) const = 0;
  virtual void install_global_change_callback( fn_change_callback callback ) = 0;
  virtual void remove_global_change_callback( fn_change_callback callback ) = 0;
  virtual void call_global_change_callbacks( convar* var, const char* old_string, float old_value ) = 0;
  virtual void install_console_display_func( fn_change_callback* display_func ) = 0;
  virtual void remove_console_display_func( fn_change_callback* display_func ) = 0;
  virtual void console_color_printf( const _color& clr, const char* format, ... ) const = 0;
  virtual void console_printf( const char* format, ... ) const = 0;
  virtual void console_d_printf( const char* format, ... ) const = 0;
  virtual void revert_flagged_ConVars( int flag ) = 0;
  virtual void install_c_var_query( i_cvar_query* query ) = 0;
  virtual bool is_material_thread_set_allowed( ) const = 0;
  virtual void queue_material_thread_set_value( convar* convar, const char* value ) = 0;
  virtual void queue_material_thread_set_value( convar* convar, int value ) = 0;
  virtual void queue_material_thread_set_value( convar* convar, float value ) = 0;
  virtual bool has_queued_material_thread_ConVar_sets( ) const = 0;
  virtual int process_queued_material_thread_ConVar_sets( ) = 0;
};